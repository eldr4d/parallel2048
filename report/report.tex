\documentclass[10pt,a4paper]{article}

\usepackage{templ}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}
%\usepackage{multirow}
%\usepackage{layouts}
\usepackage{array}
\newcommand{\sol}[1]{#1} % #1 for solution
\newcommand{\optional}[1]{#1} % #1 for showing optional

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
% Anomalies
\setlength{\textheight}{26.0cm}

\begin{document}
\opening
%{University}
{Πολυτεχνείο Κρήτης}
%{Dept}
{Τμήμα Ηλεκτρονικών Μηχανικών και Μηχανικών Υπολογιστών}
%{Course}
{Αρχιτεκτονική Παράλληλων και Κατανεμημένων Συστημάτων} % - \textlatin{Theory of Computation}}
%{Term}
{ΗΡΥ 418}
%{Assignment}
{Αναφορά Εργασίας}
%{Deadline}
{2014} \vspace{0ex}
Περικλής Χρυσόγελος Α.Μ.: 2011030064\\
Νικόλαος Κοφινάς Α.Μ.: 2011039025


Στην εργασία αυτή δημιουργήσαμε μία παράλληλη υλοποίηση του αλγορίθμου {\en negascout} για το παιχνίδι 2048. Όπως αποδείχτηκε στην πράξη στο παιχνίδι αυτό μπορούμε να δούμε αρκετές κινήσεις μπροστά αλλά ο σχεδιασμός μια καλής {\en evaluation function} δεν είναι εύκολος.

\boldmark{2048}
\noindent
Το παιχνίδι 2048  είναι ένα σχετικά καινούργιο παιχνίδι που είχε αρκετά μεγάλη απήχηση λόγο του απλού τρόπου που παίζετε. Αποτελείτε από ένα {\en board} μεγέθους $4\times4$ όπου το κάθε κελί μπορεί να περιέχει ένα {\en tile} το οποίο έχει μία τιμή ίση με κάποια δύναμη του 2(π.χ. 2, 8, 64, 512). Στην εικόνα~\ref{fig:thegame} μπορείτε να δείτε ένα στιγμιότυπο του παιχνιδιού. Σκοπός του παίχτη είναι να ενώνει {\en tiles} που έχουν την ίδια τιμή για να δημιουργήσει ένα νέο {\en tile} το οποίο θα αποτελείτε από την επόμενη δύναμη του 2 (π.χ. αν ενώσει 2 {\en tiles} με τιμή 8 θα δημιουργηθεί το {\en tile} με τιμή 16). Οι κινήσεις του παίχτη είναι το πολύ 4: πάνω, κάτω, δεξιά και αριστερά. Ύστερα από κάθε κίνηση του παίχτη ο αντίπαλος τοποθετεί ένα νέο {\en tile}, το οποίο έχει τιμή 2 ή 4 μέσα στο {\en board} σε οποία θέση θέλει. Στο κανονικό παιχνίδι ο αντίπαλος παίζει τυχαία. Οι παίκτες παίζουν εναλλάξ ξεκινώντας από τον παίχτη ο οποίος κάνει τις 4 κινήσεις και με ένα {\en board} το οποίο περιέχει 2 {\en tiles} τυχαία τοποθετημένα και με τιμές 2 ή 4. Για περισσότερες πληροφορίες μπορείτε να παίξετε το κανονικό παιχνίδι σε αυτό το {\en link}: {\en \url{http://gabrielecirulli.github.io/2048/}}

\begin{figure}[h]
\centering
\includegraphics[width = 0.2\textwidth]{thegame.png}
\caption{Ένα στιγμιότυπο του παιχνιδιού}
\label{fig:thegame}
\end{figure}

\boldmark{\en MiniMax}
\noindent
Στην θεωρία της τεχνητής νοημοσύνης ο αλγόριθμος {\en Mini-Max} είναι ίσος ο πιο γνωστός αλγόριθμος αναζήτησης που χρησιμοποιείται σε ανταγωνιστικά παιχνίδια δύο ατόμων. Η γενική ιδέα πίσω από τον αλγόριθμο είναι ότι κοιτάζοντας μπροστά στον χώρο των πιθανών κινήσεων πια είναι η βέλτιστη κίνηση που μπορώ να κάνω αυτή την στιγμή. Για να δει μέσα στο χώρο όλων των πιθανών κινήσεων, ``παίζει'' οποιαδήποτε κίνηση μπορεί να κάνει ο παίχτης στην κατάσταση στην οποία βρίσκετε το παιχνίδι...

\boldmark{\en Mini-Max alpha beta prunning}
\noindent
Ο {\en Mini-max} είναι αρκετά αργός και απαιτεί εκθετικό χρόνο για να εκτελεστεί. Με την επέκταση {\en alpha-beta pruning}, δεν μπορούμε να διώξουμε τον εκθέτη, αλλά μπορούμε να τον μειώσουμε στο μισό. Η λογική του {\en alpha-beta pruning} είναι πολύ απλή, όταν ένας κόμβος καλεί μια συνάρτηση για να αξιολογήσει την κατάσταση στην οποία βρέθηκε μετά από μία κίνηση, ελέγχει τι του επιστρέφει και αν του κάνει, σε σχέση με το προηγούμενο που είχε, το κρατάει και πετάει το προηγούμενο. Με το {\en alpha-beta pruning} μπορούμε να προωθούμε την τιμή που έχουμε, στους από κάτω κόμβους, ώστε αν αυτοί βρουν τιμή μεγαλύτερη από αυτή που έχει προωθήσει ο από πάνω κόμβος (στην περίπτωση του {\en max} κόμβου) ή μικρότερη (στην περίπτωση του {\en min} κόμβου) τότε την επιστρέφουν αμέσως, χωρίς να επεκτείνουν τα εναπομείναντα παιδιά. Ο λόγος που λειτουργεί αυτό, είναι διότι ο {\en minimax} αλγόριθμος, θα τα απέρριπτε αυτά τα παιδιά από αυτή και μόνο την τιμή, χωρίς να τον ενδιαφέρει αν υπάρχει μεγαλύτερη η μικρότερη τιμή, γιατί σίγουρα δεν θα επέλεγε αυτή την κίνηση, οπότε  δεν χρειάζεται περαιτέρω ψάξιμο.

\boldmark{\en Negascout}
\noindent
Ο αλγόριθμος {\en negascout} είναι μία βελτίωση του {\en mini-max alpha beta prunning} που δουλεύει πάνω σε μία απλή υπόθεση. Η υπόθεση είναι ότι πάντα θα εξετάζει πρώτο το παιδί που με μεγάλη πιθανότητα θα του δώσει το καλύτερο {\en score}. Για να λειτουργήσει αυτό χρειάζεται να ξέρει από προηγούμενες, πιο ρηχές αναζητήσεις την σειρά με την οποία θα εξετάσει τα παιδιά. Ο αλγόριθμος αφού εξετάσει το καλύτερο παιδί και βρει το {\en score} του, εξετάζει τα υπόλοιπα παιδιά θέτοντας $\beta = \alpha+1$ το επονομαζόμενο και {\en null window}. Η υπόθεση πίσω από το {\en null window} είναι ότι τα υπόλοιπα παιδιά θα γίνουν γρήγορα κλάδεμα διότι θα δώσουν χειρότερο {\en score} από το τωρινό. Αν το {\en null window} αποτύχει για ένα παιδί και αυτό γυρίσει διαφορετικό {\en score} τότε ο αλγόριθμος επανεξετάζει αυτό το παιδί χωρίς το {\en null window}. Στην πράξη έχει δειχθεί ότι με σωστό {\en move ordering} ο {\en negascout} έχει ένα {\en speedup} της τάξης του 10\% σε σχέση με τον {\en alpha beta prunning}.
{\en
\begin{algorithm}[h!]
\begin{algorithmic}[1]
\REQUIRE{ node,depth,$\alpha$,$\beta$,color}
\ENSURE{ score}
\IF{node is a terminal node \OR depth = 0}
\RETURN color $\times$ heuristic evaluation
\ENDIF
\FORALL{childs of node}
\IF{child is not first child}
\STATE{score := -negascout(child, depth$-1$, $-\alpha-1$, $-\alpha$, -color)}
\IF{$\alpha<$score$<\beta$}
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\ELSE
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\STATE  $\alpha$:=max($\alpha$,score);
\IF{$\alpha \ge \beta$}
\STATE break
\ENDIF
\ENDFOR
\RETURN $\alpha$
\end{algorithmic}
\caption{Negascout algorithm}
\label{Alg:nega}
\end{algorithm}
}

\boldmark{\en Board}
Μέχρι αυτό το σημείο, για να υλοποιηθεί οποιοσδήποτε από αυτούς τους αλγορίθμους, το μόνο επιπλέον που χρειάζεται είναι μια αναπαράσταση της κατάστασης του παιχνιδιού και υλοποίηση των κανόνων/κινήσεων του παιχνιδιού πάνω σε αυτή την αναπαράσταση. Για λόγους απόδοσης επιλέχθηκε το {\en Board} να αναπαριστάται με τέσσερα {\en bitboard}. Δηλαδή, για την αναπαράσταση θα χρησιμοποιούνται τέσσερις 64{\en bit} ακέραιοι, οι οποίοι θα περιέχουν συνολικά 16 {\en boards}. Κάθε {\en bitboard} θα περιέχει 16 {\en bits} ένα για κάθε τετράγωνο του ταμπλό. Από τα 16 {\en boards}, τα ένα αποφασίστηκε να κρατάει τα τετράγωνα που είναι γεμάτα, ενώ τα άλλα 15 χρησιμοποιούνται ένα για κάθε δύναμη του 2 (ξεκινώντας από το 2) και δίνοντας δυνατότητες για κομμάτια τιμής μέχρι και $2^{15} = 32768$. Επίσης 256 {\en bits} χωράν σε μια γραμμή της {\en L1 cache} των περισσότερων επεξεργαστών, έτσι ο {\en compiler} έχει την δυνατότητα να κάνει σωστή ευθυγράμμιση ώστε να γίνεται καλύτερη αξιοποίηση της {\en L1 cache} μνήμης. Επιπλέον, με αυτή την υλοποίηση που έγινε, οι περισσότερες πράξεις αφορούσαν {\en bitwise operations} και μάλιστα πολλά από αυτά μέσα σε {\en vectorizable loops} ή ακόμη γενικότερα, μπορούσαν να χρησιμοποιηθούν για τις περισσότερες πράξεις {\en SSE/AVX instructions}, δίνοντας την δυνατότητα σε έναν καλό {\en compiler} να βελτιώσει και να επιταχύνει πολύ την {\en assembly} του κώδικα. Προφανώς αυτή η σχεδίαση αυξάνει στο μέγιστο δυνατό την παραλληλοποίηση σε επίπεδο {\en bit} και εντολών. Επιπροσθέτως αξίζει να σημειωθεί ότι με αυτή την υλοποίηση οι προσβάσεις στην μνήμη για τις περισσότερες ενέργειες τουλάχιστον υποτετραπλασιάζονται σε σχέση με την υλοποίηση με πίνακα.

\boldmark{\en Parallel Negascout}
\noindent
Η λογική που αποφασίσαμε να ακολουθήσουμε για να παραλληλοποίησουμε τον αλγόριθμο είναι η εξής:
\begin{enumerate}
\item Ψάχνουμε το ακραίο αριστερό παιδί μέχρι κάτω
\item Αναδρομικά ψάχνουμε τα αδέρφια του και τους κόμβους από πάνω του
\item Από ένα δεδομένο βάθος και πάνω αναλαμβάνει την αναζήτηση κάθε κόμβου στο δεδομένο βάθος ένα {\en thread}
\end{enumerate}
Η ιδέα πίσω από αυτή την υλοποίηση είναι πολύ απλή, ψάχνουμε να βρούμε τα πρώτα {\en alpha beta bounds} το {\en main thread} και ύστερα το {\en main thread} διαχωρίζει την δουλειά σε επιμέρους {\en threads}. Ο αλγόριθμος παρουσιάζετε στην εικόνα~\ref{Alg:pnega}.

{\en
\begin{algorithm}[h!]
\begin{algorithmic}[1]
\REQUIRE{ node,depth,$\alpha$,$\beta$,color}
\ENSURE{ score}
\IF{node is a terminal node \OR depth = 0}
\RETURN color $\times$ heuristic evaluation
\ENDIF
\FORALL{childs of node}
\IF{child is not first child}
\STATE{score := -spawnThread(child, depth$-1$, $-\alpha-1$, $-\alpha$, -color)}
\STATE{continue}
\ELSE
\STATE{score := -parallelNegascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\STATE  $\alpha$:=max($\alpha$,score);
\IF{$\alpha \ge \beta$}
\STATE break
\ENDIF
\ENDFOR

\WHILE{thread finished execution}
\STATE  $\alpha$:=max($\alpha$,score);
\IF{$\alpha$ changed}
\STATE{Inform all thread about the new alpha}
\ENDIF
\IF{$\alpha \ge \beta$}
\STATE Wait all other threads
\STATE break
\ENDIF
\ENDWHILE
\RETURN $\alpha$
\end{algorithmic}
\caption{Parallel Negascout algorithm}
\label{Alg:pnega}
\end{algorithm}
}
Για να υλοποιήσουμε την ιδέα καταρχάς δημιουργήσαμε ένα δικό μας {\en thread pool}. Το {\en thread pool} είναι αυτό το οποίο έχει δημιουργήσει από την αρχή της εκτελέσεις του προγράμματος {\en N threads} και διαμοιράζει την δουλειά που του στέλνουμε σε αυτά τα {\en threads}. Η χρήση ενός {\en thread pool} αποδείχτηκε μονόδρομος καθώς η δημιουργία νέου {\en thread} είναι πολύ ακριβή υπολογιστικά και έτσι είχαμε ένα μεγάλο {\en overhead}. Το {\en thread pool} είναι κατάλληλα δομημένο ώστε να τρέχει όπια συνάρτηση θέλουμε εμείς που δέχεται μόνο ένα όρισμα τύπου {\en struct} το οποίο το έχουμε ορίσει και πάλι εμείς. 

Τα {\en thread} που δημιουργούνται μέσα στο {\en thread pool} πρέπει να μένουν ζωντανά ακόμα και όταν τελειώσουν την δουλειά που του έχουμε αναθέσει. Για να το επιτύχουμε αυτό, χρησιμοποιούμε {\en condition variable} και ένα {\en mutex} το οποίο κλειδώνει την ουρά στην οποία αποθηκεύονται οι δουλειές που αναθέτουμε στο {\en thread pool}. Με την άφιξη κάθε νέας δουλειάς και με την εισαγωγή της στην ουρά, ενημερώνονται όλα τα {\en thread} ώστε να ξυπνήσουν και όποιο προλάβει να ξεκινήσει να εκτελείτε.

Αυτό που παρατηρήσαμε άμεσα ήταν ότι στην παράλληλη εκδοχή του αλγορίθμου είναι απαραίτητο να ενημερώνονται όλα τα {\en threads} για οποιαδήποτε αλλαγή γίνετε στα {\en alpha} και στα {\en beta}. Παρατηρήσαμε ότι στην πρώτη έκδοση που δεν το είχαμε υλοποιήσει αυτό, πήραμε αρνητικό {\en speedup} ενώ μόλις το υλοποιήσαμε η διαφορά ήταν πολύ μεγάλη. Ο λόγος που γινόταν αυτό ήταν διότι μπορεί ένα {\en thread} να έβρισκε τα ιδανικά {\en alpha beta} και όλα τα άλλα {\en thread} να τερμάτιζαν άμεσα αν τα γνώριζαν.

\boldmark{\en Transposition Table}
Ο επιλεγμένος αλγόριθμος όμως κρύβει καλά μια παραδοχή, ότι το αριστερό παιδί έχει την βέλτιστη τιμή ή τουλάχιστον την προσεγγίζει αρκετά. Για να το δούμε αυτό καλύτερα πρέπει να εξετάσουμε δυο περιπτώσεις.

Η πρώτη περίπτωση είναι το αριστερό παιδί να είναι το βέλτιστο. Σε αυτή την περίπτωση το {\en main thread} θα ψάξει μέχρι το τέλος του υπό-δέντρου (χρησιμοποιώντας κάποια {\en threads} στα επόμενα βάθη). Αφού το βέλτιστο βρίσκεται σε αυτό το υπό-δέντρο, σύμφωνα με την θεωρία που βρίσκεται πίσω από το {\en alpha beta pruning}, το κόστος να ψάξουμε αυτό το υπό-δέντρο θα είναι μεγαλύτερο από οποιοδήποτε άλλο δέντρο ίδιου μεγέθους. Μάλιστα, αφού έχει εντοπισθεί η βέλτιστη κίνηση, η δουλειά των {\en threads} θα είναι αρκετά μικρότερη, ώστε να θεωρήσουμε ότι θα τελειώσουν σε σχετικά κοντινούς χρόνους.

Στην δεύτερη περίπτωση όπου το αριστερό παιδί δεν είναι το βέλτιστο, μπορεί να επιστραφεί ένα αρκετά μεγάλο παράθυρο. Αυτό μεταφράζετε σε πολύ λιγότερα {\en cut-offs}, δηλαδή πολύ δουλειά για τουλάχιστον ένα {\en thread}, άρα κακό {\en balancing} και μεγάλο {\en idle time}.

Για αυτό έπρεπε κάπου να αποθηκεύονται για κάποιες θέσεις οι βέλτιστες κινήσεις από προηγούμενες αναζητήσεις, ώστε να αναζητούνται πρώτες. 
Επίσης, όλοι οι αλγόριθμοι αναζήτησης σε δέντρα παιχνιδιών στα οποία συναντάμε πολλές φορές την ίδια θέση παίζοντας διαφορετικές κινήσεις ({\en transpositions}), επιταχύνονται αισθητά με την χρήση του {\en Transposition Table}.

Το {\en Transposition Table} είναι ένα {\en hashtable} στο οποίο με βάση ένα {\en hash} που προσδιορίζεται από την κατάσταση του παιχνιδιού αποθηκεύονται διάφορες πληροφορίες για εκείνη την θέση. Με βάση τον τρόπου που στήσαμε το {\en board}, αποφασίσαμε ότι το {\en hash} θα έχει μέγεθος 64{\en bit} και θα είναι μοναδικό για κάθε θέση, αλλά δεν θα συμπεριλαμβάνει πληροφορία για το ποιος παίχτης είναι ο επόμενος. Επίσης σε 32{\en bit} μπορούσε να αποθηκευτεί όλη η πληροφορία που θέλαμε να κρατάμε για κάθε θέση, έτσι αποφασίσαμε να δημιουργήσουμε προσεκτικά το {\en Transposition Table} ώστε να αποθηκεύει δυο {\en entries} ανά θέση, ένα για κάθε παίχτη που έχει σειρά, αλλά στην ίδια θέση (ίδιο πλήρες {\en hash}). 
Σε αυτόν τον χώρο (32{\en bit}) αποθηκευόταν πληροφορία για το βάθος στο οποίο είναι υπολογισμένα τα αποτελέσματα του {\en entry}, ένα {\en score}, το οποίο μπορούσε να ήταν πάνω όριο, κάτω όριο, ή ακριβές {\en score}, άρα και η πληροφορία για το τι είδους ήταν και την καλύτερη κίνηση {\en killer move}%
\footnote{όρος από τις σκακιστικές μηχανές, ονομάζεται έτσι επειδή δεδομένου ότι θα ψαχτεί σχετικά νωρίς θα σκοτώσει αρκετές αναζητήσεις νωρίς λόγω cut-offs από το παράθυρο που θα προκαλέσει}. Μαζί με κάθε ζεύγος από {\en entries} είναι απαραίτητο να αποθηκευτεί και το {\en hash}

Το μέγεθος του {\en Transposition Table} ορίστηκε για τις περισσότερες δοκιμές σε {\en 0x7fffff hash entries} (ή {\en 0xffffffe entries}), αλλά αλλάζει πολύ εύκολα. Το κλειδί για την αναζήτηση μέσα στο {\en Transposition Table} ήταν το {\en hash mod \#hashEntries}.

Από το {\en Transposition Table} με κατάλληλο πρωτόκολλο αντικατάστασης και κάποιες άλλες προσεκτικές ενέργειες, μπορεί στο τέλος της αναζήτησης να εξαχθεί η τελική κίνηση και μάλιστα ένα μέρος της βέλτιστης σειράς κινήσεων.

\boldmark{\en Simultaneous Access to Transposition Table} 
Κάθε κόμβος του δέντρου αντλεί δεδομένα με το που ξεκινάει και σώζει λίγο πριν βγει, εκτός αν είναι {\en leaf node}. Αυτό καθιστά δύσκολη την πρόσβαση στο {\en Transposition Table} μέσω κάποιου μηχανισμού με {\en locks}. Μάλιστα, πειραματικά μπορεί να δειχτεί ότι στις περισσότερες περιπτώσεις είναι πολύ μικρό το κέρδος ή σε ακραίες περιπτώσεις μπορεί να είναι καλύτερο να μην υπάρχει το {\en Transposition Table} από το να γίνεται η πρόσβαση με {\en locks}.

Με βάση αυτή την παρατήρηση, οι σκακιστικές μηχανές χρησιμοποιούν μια αρκετά ενδιαφέρουσα {\en lock-less} προσέγγιση η οποία υιοθετήθηκε και στο {\en project}. Αφού τελικώς θα αποθηκευτούν δυο 64{\en bit} δεδομένα ({\en hash + data}), θα αποθηκευτεί το {\en hash XORed} με τα {\en data} αντί του {\en hash} με τα {\en data}. Έτσι, όταν θα γίνει ανάγνωση από το {\en Transposition Table} των δυο τιμών, ($Α \triangleq hash_{TT} \oplus data_{TT}, B \triangleq data_{TT}$) μπορούν να υπολογιστούν τα $hash_{TT} \equiv A \oplus B, data_{TT} \equiv A$. Μετά, το $hash$ θα συγκριθεί με το $A \oplus B$ το οποίο περιέχει πληροφορία από όλο το {\en entry}. Αν κάποιο άλλο/άλλα {\en thread} είναι στην διαδικασία να γράψουν το {\en entry} αλλά δεν την έχουν ολοκληρώσει, τότε η πιθανότητα το {\en hash} να ταιριάξει με το $A \oplus B$ είναι πολύ μικρή, καθώς θα πρέπει $hash = hash_{TT} \oplus data_{{T1}_{TT}} \oplus data_{{T2}_{TT}}$. Σε αυτή την περίπτωση (που δεν είχαμε ταίριασμα), αν κάνουμε ανάγνωση η καλύτερη μεθοδολογία λέει απλώς συνεχίζουμε σαν να είχαμε {\en miss}. Προφανώς αν κάποιο άλλο {\en thread} έχει γράψει τα δεδομένα του πλήρως και μας ταιριάζουν, ο έλεγχο $A \oplus B = hash$ θα βγει αληθής και θα γίνει κανονικά η ανάγνωση. Η όλη διαδικασία και στις δυο περιπτώσεις είναι {\en lock-less} αλλά και {\en thread safe}.

\boldmark{\en Evaluation function} 
Η συνάρτηση αξιολόγησης που φτιάξαμε είναι αρκετά απλή και δημιουργήθηκε κυρίως από την δικιά μας πίρα παίζοντας το παιχνίδι. Από τα πρώτα παιχνίδια καταλάβαμε ότι για να σχηματίσουμε όσο το δυνατών μεγαλύτερο {\en tile} πρέπει να ``κολλήσουμε'' το μεγαλύτερο {\en tile} που έχουμε την εκάστοτε χρονική στιγμή σε μία γωνία. Ο λόγος που γίνετε αυτό είναι διότι συνήθως το μέγιστο {\en tile} δεν μας εξυπηρετεί στην διάρκεια του παιχνιδιού και θέλουμε να έχουμε χώρο να ενώνουμε όλα τα άλλα μας {\en tiles}. 

Βασιζόμενοι στην παραπάνω ιδέα βρήκαμε ότι πρέπει γενικά τα {\en tiles} μας να είναι στοιχισμένα διαδοχικά από το μεγαλύτερο στο μικρότερο σε μία λογική αλυσίδας. Η λογική της αλυσίδας βοηθάει στο να κάνουμε {\en collapse} όλα τα {\en tiles} σε ένα μεγάλο και μπορούμε να δούμε ένα παράδειγμα αλυσίδας στην εικόνα~\ref{fig:thegame}. Σε αυτή την εικόνα είναι εύκολο να δούμε ότι σε 4 κινήσεις θα έχουμε δημιουργήσει το {\en tile} 256. Επίσης είδαμε ότι δύο ακόμη παράγοντες που επηρεάζουν σχετικά λίγο το παιχνίδι είναι ο αριθμός τον ελεύθερων {\en tiles} που έχουμε καθώς και την ποικιλία από {\en tiles}. 

Το δύσκολο κομμάτι το οποίο ακόμα είναι υπό υλοποίηση είναι να βρεθούν τα κατάλληλα βάρη για αυτές τις τιμές. Εμείς όπως θα δείξουμε και στα {\en results} φτάσαμε πολύ κοντά στο να δημιουργήσουμε το {\en tile} 4096 και πιστεύουμε ότι με λίγο {\en tune} του {\en evaluation function} θα μπορέσουμε να φτάσουμε και πιο μεγάλα {\en tiles}. Τέλος να πούμε ότι όταν ο ``παίκτης'' βλέπει τέλος παιχνιδιού, το {\en score} που γυρνάει η {\en evaluation function} είναι το μεγαλύτερο {\en tile} που έχει φτιάξει μέχρι εκείνη την στιγμή. Ουσιαστικά εμάς μας νοιάζει μόνο το μεγαλύτερο {\en tile} και όχι το συνολικό {\en score} του παιχνιδιού.


\boldmark{\en Compile and Run}
Για να γίνει {\en build} το {\en project}, στον κύριο φάκελό του, εκτελείται {\en make all} και μετά σε τρία διαφορετικά {\en terminal} τα:
\begin{itemize}
    \item $./parallel\_server\ 1$\\
        για να τρέξει ο {\en game server} ο οποίος περιμένει να συνδεθούν οι παίχτες και παρουσιάζει το παιχνίδι με γραφικά
    \item $./parallel\_client\ placer$\\
        στο {\en terminal} που θέλετε να βρίσκεται ο {\en placer}
    \item $./parallel\_client\ normal$\\
        στο {\en terminal} που θέλετε να βρίσκεται ο {\en normal}, θα εμφανίζονται οι έξοδοι του {\en normal} και τα αποτελέσματα ανά βάθος του {\en iterative deepening} 
\end{itemize}

Σημειώνεται ότι χρειάζεται {\en compiler} που υποστηρίζει {\en C++11} και όλες οι δοκιμές έχουν γίνει με τον {\en g++ 4.8.2}.

\boldmark{\en Results}
\noindent
Πριν προχωρήσουμε στην παρουσίαση των αποτελεσμάτων πρέπει να πούμε ότι στα παιχνίδια που έπαιζε ο παίχτης μας, ο αντίπαλος (ο παίχτης που τοποθετεί τα νέα {\en tiles} στο {\en board}) ήταν πάντα ο {\en random}. Είδαμε ότι όταν βάζαμε τον {\en negascout} να παίζει σαν αυτόν τον παίχτη τότε δεν πετυχαίναμε μεγάλο {\en score} διότι είναι πολύ εύκολο να εμποδίσεις τις κινήσεις του {\en normal} παίχτη. 

Όπως αναφέραμε και πιο πάνω καταφέραμε και φτιάξαμε το {\en tile} 2048 και φτάσαμε και πολύ κοντά στο 4096. Το ενδιαφέρον αποτέλεσμα όμως δεν είναι το {\en highest tile} που φτάσαμε αλλά το ότι όταν ο {\en negascout} έτρεχε με την παράλληλη έκδοση το βάθος που ψάχναμε έφτασε κατά μέσο όρο να είναι το 23 ενώ όταν έτρεχε σειριακά έφτανε κατά μέσο όρο μέχρι 18. Η διαφορά αυτή είναι αρκετά μεγάλη μιας και με κάθε αύξηση του βάθους το {\en search space} αυξάνετε εκθετικά. Επίσης πρέπει να προσθέσουμε ότι για κάθε κίνηση είχε στην διάθεση του μόνο 0.8 {\en second} μιας και όπως βρήκαμε από διάφορα στατιστικά αυτή είναι η μέση ταχύτητα που παίζει ένα έμπυρος παίκτης στα πρώτα στάδια του παιχνιδιού. 

Γενικά το επιπλέον βάθος που πήραμε με την βοήθεια της παραλληλοποίησης βοήθησε αρκετά στο να φτάνουμε καλύτερο τελικό {\en score}. Στην βιβλιογραφία υπάρχουν και άλλοι τρόποι να τρέξει παράλληλα ο {\en negascout} άλλα το κύριο πρόβλημα με αυτούς τους αλγορίθμους είναι η δυσκολία υλοποίησης τους στην πράξη. Γενικά θα είχε ενδιαφέρον να εξετάσει κανείς το τελικό βάθος που θα μπορούσε να φτάσει κάποιος με μια νέα υλοποίηση!





\end{document}