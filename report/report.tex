\documentclass[10pt,a4paper]{article}

\usepackage{templ}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}
%\usepackage{multirow}
%\usepackage{layouts}
\usepackage{array}
\newcommand{\sol}[1]{#1} % #1 for solution
\newcommand{\optional}[1]{#1} % #1 for showing optional

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
% Anomalies
\setlength{\textheight}{26.0cm}

\begin{document}
\opening
%{University}
{Πολυτεχνείο Κρήτης}
%{Dept}
{Τμήμα Ηλεκτρονικών Μηχανικών και Μηχανικών Υπολογιστών}
%{Course}
{Αρχιτεκτονική Παράλληλων και Κατανεμημένων Συστημάτων} % - \textlatin{Theory of Computation}}
%{Term}
{ΗΡΥ 418}
%{Assignment}
{Αναφορά Εργασίας}
%{Deadline}
{2014} \vspace{-5ex}
Περικλής Χρυσόγελος Α.Μ.:\\
Νικόλαος Κοφινάς Α.Μ.:


Στην εργασία αυτή δημιουργήσαμε μία παράλληλη υλοποίηση του αλγορίθμου {\en negascout} για το παιχνίδι 2048. Όπως αποδίχτικε στην πράξη στο παιχνίδι αυτό μπορούμε να δούμε αρκετές κινίσεις μπροστά αλλά ο σχεδιασμός μια ``καλής'' {\en evaluation function} δεν είναι εύκολος.

\boldmark{2048}
\noindent
Το παιχνίδι 2048 είναι ένα σχετικά καινούργιο παιχνίδι που είχε αρκετά μεγάλη απήχηση λόγο του απλού τρόπου που παίζετε. Αποτελείτε από ένα {\en board} μεγέθους $4\times4$ όπου το κάθε κελί μπορεί να περιέχει ένα tile το οποί έχει μία τιμή ίση με κάποια δύναμη του 2(π.χ. 2, 8, 64, 512). Σκοπός του παίχτη είναι να ενώνει {\en tiles} που έχουν την ίδια τιμή για να δημιουργήσει ένα νέο {\en tile} το οποίο θα αποτελείτε από την επόμενη δύναμη του 2 (π.χ. αν ενώσει 2 {\en tiles} με τιμή 8 θα δημιουργηθεί το tile με τιμή 16). Οι κινήσεις του παίχτη είναι το πολύ 4: πάνω, κάτω, δεξιά και αριστερά. Ύστερα από κάθε κίνηση του παίχτη ο ``αντίπαλος'' τοποθετεί ένα νέο {\en tile}, το οποίο έχει τιμή 2 ή 4 μέσα στο {\en board} σε οποία θέση θέλει. Στο κανονικό παιχνίδι ο  ``αντίπαλο'' παίζει τυχαία. Οι παίκτες παίζουν εναλλάξ ξεκινώντας από τον παίχτη ο οποίος κάνει τις 4 κινήσεις και με ένα {\en board} το οποίο περιέχει 2 {\en tiles} τυχαία τοποθετημένα και με τιμές 2 ή 4. Για περισσότερες πληροφορίες μπορείτε να παίξετε το κανονικό παιχνίδι σε αυτό το link: {\en \url{http://gabrielecirulli.github.io/2048/}}

\boldmark{\en MiniMax}
\noindent
Στην θεωρία της τεχνητής νοημοσύνης ο αλγόριθμος {\en Mini-Max} είναι ίσος ο πιο γνωστός αλγόριθμος αναζήτησης που xρησιμοποιείται σε ανταγωνιστικά παιχνίδια δύο ατόμων. Η γενική ιδέα πίσω από τον αλγόριθμο είναι ότι κοιτάζοντας μπροστά στον χώρο των πιθανών κινήσεων πια είναι η βέλτιστη κίνηση που μπορώ να κάνω αυτή την στιγμή. Για να δει μέσα στο χώρο όλων των πιθανών κινήσεων, ``παίζει'' οποιαδήποτε κίνηση μπορεί να κάνει ο παίχτης στην κατάσταση στην οποία βρίσκετε το παιχνίδι...

\boldmark{\en Mini-Max alpha beta prunning}
\noindent
Ο {\en Mini-max} είναι αρκετά αργός και απαιτεί εκθετικό χρόνο για να εκτελεστεί. Με την επέκταση {\en alpha-beta pruning}, δεν μπορούμε να διώξουμε τον εκθέτη, αλλά μπορούμε να τον μειώσουμε στο μισό. Η λογική του {\en alpha-beta pruning} είναι πολύ απλή, όταν ένας κόμβος καλεί μια συνάρτηση για να αξιολογήσει την κατάσταση στην οποία βρέθηκε μετά από μία κίνηση, ελέγχει τι του επιστρέφει και αν του κάνει, σε σχέση με το προηγούμενο που είχε, το κρατάει και πετάει το προηγούμενο. Με το {\en alpha-beta pruning} μπορούμε να προωθούμε την τιμή που έχουμε, στους από κάτω κόμβους, ώστε αν αυτοί βρουν τιμή μεγαλύτερη από αυτή που έχει προωθήσει ο από πάνω κόμβος (στην περίπτωση του {\en max} κόμβου) ή μικρότερη (στην περίπτωση του {\en min} κόμβου) τότε την επιστρέφουν αμέσως, χωρίς να επεκτείνουν τα εναπομείναντα παιδιά. Ο λόγος που λειτουργεί αυτό, είναι διότι ο {\en minimax} αλγόριθμος, θα τα απέρριπτε αυτά τα παιδιά από αυτή και μόνο την τιμή, χωρίς να τον ενδιαφέρει αν υπάρχει μεγαλύτερη η μικρότερη τιμή, γιατί σίγουρα δεν θα επέλεγε αυτή την κίνηση, οπότε  δεν χρειάζεται περαιτέρω ψάξιμο.

\boldmark{\en Negascout}
\noindent

\boldmark{\en Parallel Negascout}
\noindent

\boldmark{\en Evaluation function} 
Η συνάρτηση αξιολόγησης που φτιάξαμε είναι αρκετά απλή και δημιουργήθηκε κυρίως από την δικιά μας πίρα παίζοντας το παιχνίδι. Από τα πρώτα παιχνίδια καταλάβαμε ότι για να σχηματίσουμε όσο το δυνατών μεγαλύτερο {\en tile} πρέπει να ``κολλήσουμε'' το μεγαλύτερο {\en tile} που έχουμε την εκάστοτε χρονική στιγμή σε μία γωνία. Ο λόγος που γίνετε αυτό είναι διότι συνήθως το μέγιστο {\en tile} δεν μας εξυπηρετεί στην διάρκεια του παιχνιδιού και θέλουμε να έχουμε χώρο να ενώνουμε όλα τα άλλα μας {\en tiles}. 

Βασιζόμενοι στην παραπάνω ιδέα βρήκαμε ότι πρέπει γενικά τα {\en tiles} μας να είναι στοιχισμένα διαδοχικά από το μεγαλύτερο στο μικρότερο σε μία λογική αλυσίδας. Η λογική της αλυσίδας βοηθάει στο να κάνουμε {\en collapse} όλα τα {\en tiles} σε ένα μεγάλο και μπορούμε να δούμε ένα παράδειγμα αλυσίδας στην εικόνα~\ref{}. Σε αυτή την εικόνα είναι εύκολο να δούμε ότι σε 4 κινήσεις θα έχουμε δημιουργήσει το {\en tile} 256. Επίσης είδαμε ότι δύο ακόμη παράγοντες που επηρεάζουν σχετικά λίγο το παιχνίδι είναι ο αριθμός τον ελεύθερων {\en tiles} που έχουμε καθώς και την ποικιλία από {\en tiles}. 

Το δύσκολο κομμάτι το οποίο ακόμα είναι υπό υλοποίηση είναι να βρεθούν τα κατάλληλα βάρη για αυτές τις τιμές. Εμείς όπως θα δείξουμε και στα {\en results} φτάσαμε πολύ κοντά στο να δημιουργήσουμε το {\en tile} 4096 και πιστεύουμε ότι με λίγο {\en tune} του {\en evaluation function} θα μπορέσουμε να φτάσουμε και πιο μεγάλα {\en tiles}. Τέλος να πούμε ότι όταν ο ``παίκτης'' βλέπει τέλος παιχνιδιού, το {\en score} που γυρνάει η {\en evaluation function} είναι το μεγαλύτερο {\en tile} που έχει φτιάξει μέχρι εκείνη την στιγμή. Ουσιαστικά εμάς μας νοιάζει μόνο το μεγαλύτερο {\en tile} και όχι το συνολικό {\en score} του παιχνιδιού.

\boldmark{\en Results}
\noindent
Πριν προχωρήσουμε στην παρουσίαση των αποτελεσμάτων πρέπει να πούμε ότι στα παιχνίδια που έπαιζε ο ``παίχτης'' μας, ο αντίπαλος (ο παίχτης που τοποθετεί τα νέα {\en tiles} στο {\en board}) ήταν πάντα ο {\en random}. Είδαμε ότι όταν βάζαμε τον {\en negascout} να παίζει σαν αυτόν τον παίχτη τότε δεν πετυχαίναμε μεγάλο {\en score} διότι είναι πολύ εύκολο να εμποδίσεις τις κινήσεις του {\en normal} παίχτη. 

Όπως αναφέραμε και πιο πάνω καταφέραμε και φτιάξαμε το {\en tile} 2048 και φτάσαμε και πολύ κοντά στο 4096. Το ενδιαφέρον αποτέλεσμα όμως δεν είναι το {\en highest tile} που φτάσαμε αλλά το ότι όταν ο {\en negascout} έτρεχε με την παράλληλη έκδοση το βάθος που ψάχναμε έφτασε κατά μέσο όρο να είναι το 23 ενώ όταν έτρεχε σειριακά έφτανε κατά μέσο όρο μέχρι 18. Η διαφορά αυτή είναι αρκετά μεγάλη μιας και με κάθε αύξηση του βάθους το {\en search space} αυξάνετε εκθετικά. Επίσης πρέπει να προσθέσουμε ότι για κάθε κίνηση είχε στην διάθεση του μόνο 0.8 {\en second} μιας και όπως βρήκαμε από διάφορα στατιστικά αυτή είναι η μέση ταχύτητα που παίζει ένα έμπυρος παίκτης στα πρώτα στάδια του παιχνιδιού. 

Γενικά το επιπλέον βάθος που πήραμε με την βοήθεια της παραλληλοποίησης βοήθησε αρκετά στο να φτάνουμε καλύτερο τελικό {\en score}. Στην βιβλιογραφία υπάρχουν και άλλοι τρόποι να τρέξει παράλληλα ο {\en negascout} άλλα το κύριο πρόβλημα με αυτούς τους αλγορίθμους είναι η δυσκολία υλοποίησης τους στην πράξη. Γενικά θα είχε ενδιαφέρον να εξετάσει κανείς το τελικό βάθος που θα μπορούσε να φτάσει κάποιος με μια νέα υλοποίηση!
{\en
\begin{algorithm}[h!]
\begin{algorithmic}[1]
\REQUIRE{ node,depth,$\alpha$,$\beta$,color}
\ENSURE{ score}
\IF{node is a terminal node \OR depth = 0}
\RETURN color $\times$ heuristic evaluation
\ENDIF
\FORALL{childs of node}
\IF{child is not first child}
\STATE{score := -negascout(child, depth$-1$, $-\alpha-1$, $-\alpha$, -color)}
\IF{$\alpha<$score$<\beta$}
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\ELSE
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\STATE  $\alpha$:=max($\alpha$,score);
\IF{$\alpha \ge \beta$}
\STATE break
\ENDIF
\ENDFOR
\RETURN $\alpha$
\end{algorithmic}
\caption{Negascout algorithm}
\label{Alg:CYKalg}
\end{algorithm}
}



{\en
\begin{algorithm}[h!]
\begin{algorithmic}[1]
\REQUIRE{ node,depth,$\alpha$,$\beta$,color}
\ENSURE{ score}
\IF{node is a terminal node \OR depth = 0}
\RETURN color $\times$ heuristic evaluation
\ENDIF
\FORALL{childs of node}
\IF{child is not first child}
\STATE{score := -negascout(child, depth$-1$, $-\alpha-1$, $-\alpha$, -color)}
\IF{$\alpha<$score$<\beta$}
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\ELSE
\STATE{score := -negascout(child, depth$-1$, $-\beta$, $-\alpha$, -color)}
\ENDIF
\STATE  $\alpha$:=max($\alpha$,score);
\IF{$\alpha \ge \beta$}
\STATE break
\ENDIF
\ENDFOR
\RETURN $\alpha$
\end{algorithmic}
\caption{Parallel Negascout algorithm}
\label{Alg:CYKalg}
\end{algorithm}
}
\end{document}

